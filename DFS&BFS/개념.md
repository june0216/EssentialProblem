# 그래프

- 정점(혹은 노드)와 간선으로
- 두 노드가 인접하다 = 간선으로 연결되어 있다.
- 표현 2가지 방법
    - 1) 인접 행렬
        - 연결되어 있지 않은 노드끼리는 무한의 비용임
    - 2) 인접 리스트
        - 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
        - 파이썬에서 리스트 자료형이 연결 리스트의 기능과 유사한 append() 를 제공하므로 단순히 2차원 배열을 사용하면 된다(인접 행렬과 같은 방식)

# DFS

- 깊이 우선 탐색 (깊게 탐색)
- 스택 이용(재귀함수로 구현)
    - 1) 탐색 시작 노드를 스택에 삽입하고 방문 처리
    - 2) 스택의 최상단 노드에 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
    - 3) 2번의 과정을 더 이상 수행할 수 없을때까지 반복
- 인접한 노드 중에서 방문하지 않은 노드가 여러 개 있으면 번호가 낮은 순서부터 처리한다.
- 그래프 탐색의 경우 어떤 노드를 **방문했었는지 여부를 반드시 검사**해야한다. (이를 검사하지 않을 경우 무한루프에 빠질 수 있다. )
- 갈 수 있을 때까지 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색
- 모든 노드를 방문하고자할 때 이 방법 선택
- 시간복잡도 = O(N)
- 구현코드

    ```java
    
    static boolean[] check;
    public static void dfs(int start) {
    		check[start] = true;
    		System.out.println(start + " ");
    		
    		for(int i = 0 ; i <= node ; i++) {
    			if(arr[start][i] == 1 && !check[i])
    				dfs(i);
    		}
    		
    	}
    ```

- 예시 문제
    - 미로 문제

# BFS

- 너비 우선 탐색 (넓게 탐색)
- 가까운 노드부터 탐색하고 점차 멀리 떨어져있는 정점을 방문
- 큐 이용 (Deque로 구현)
    - 1) 탐색 시작 노드를 큐에 삽입하고 방문처리
    - 2) 큐에서 노드를 꺼내 해당 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 한다.
    - 3) 2번의 과정을 더 이상 수행할 수 없을 때까지 반복
- 그래프 탐색의 경우 어떤 노드를 **방문했었는지 여부를 반드시 검사**해야한다. (이를 검사하지 않을 경우 무한루프에 빠질 수 있다. )
- 시간복잡도 = O(N)
    - 실제 수행시간은 DFS 보다 좋은 편
- 구현 코드

    ```java
    	static Deque<Integer> q = new ArrayDeque<>();
    	static boolean[] check;
    	
    	public static void bfs(int start) {
    		q.add(start);
    		check[start] = true;
    		
    		while(!q.isEmpty()) {
    			
    			start = q.poll();
    			System.out.println(start + " ");
    			
    			for(int i = 1 ; i <= node ; i++) {
    				if(arr[start][i] == 1 && !check[i]) {
    					q.add(i);
    					check[i] = true;
    				}
    			}
    		}
    		
    		
    	}
    ```

- 예시문제
    - 최단경로